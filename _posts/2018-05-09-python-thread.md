---
title: Python线程模块介绍
key: 20180509
tags: python thread
---

本文介绍了Python内置的threading模块的使用以及几种线程间同步的方法
<!--more-->

在使用CPyhton解释器的情况下，因为众所周知的**全局解释器锁**(GIL)的存在，解释器在同一时刻只能运行一个线程的代码，并不能做到并行。

但这不意味着在Python中线程就毫无用处。对于**CPU密集型**的程序来说，由于GIL的存在，系统在不同切换进程的过程中耗费巨大，程序性能会差的一塌糊涂；但是对于**I/O密集型**程序，由于标准库中所有执行阻塞型I/O操作的函数在等待操作系统返回结果时都会释放GIL，所以I/O密集型程序可以从Python多线程中受益。

下面简单介绍Python中多线程模块的使用，以及线程间同步机制。

Python处理线程的模块为`threading`，该模块是对底层模块`_thread`的一个封装，编写应用程序时一般应使用`threading`来构建多线程代码。

---

### 线程对象

`threading`模块中定义了`Thread`类，该类表征了系统的一个线程，通过类实例实现对线程的控制。

将一个可执行对象函数传入`Thread`类来派生出一个新的线程用于执行该可执行函数。最常见的使用`Thread`的方法如下面代码所示：
```
from threading import Thread

def f():
    # do some thing
    returun

mythread = Thread(target=f)
mythread.start()
mythread.join()
```
将需要在新的线程中执行的函数f传给`Thread`的构造函数的`target`参数生成一个新的线程实例。但是这时线程还没有启动，需要调用实例方法`start()`来启动线程。可以在当前线程中执行`join()`方法，`join()`会阻塞当前线程，直到等待的新线程执行结束返回或因异常退出。

每个已经启动`Thread`对象都有一个唯一标识符，通过`ident`属性获取，该标识符可以用来区分线程局部变量，即`thread-local data`。

使用方法`is_alive()`检测线程是否还存活。

### 线程局部变量

线程局部变量(Thread-local data)即该变量在不同的线程中分别维护了一个副本，每个线程只能看到自己线程中这个变量的副本。而一般的全局变量在不同的线程中指向同一个对象。

`threading.local`类用于创建一个管理线程局部变量的对象，对其进行**属性赋值**，该属性就变成线程相关的了。使用方法如下：
```
import threading

mydata = threading.local()
mydata.x = 1
```
在不同的线程中对mydata的属性x赋值，线程只能看到自身对该属性赋值的结果。

---

### 线程同步机制

多线程程序经常需要在不同线程中同步操作，比如生产者-消费者模型。

线程间同步机制：Lock, Condition, Semaphore和Event

#### 1. 线程锁

Python支持两种类型的锁：简单锁和可重入锁，分别由`threading.Lock`和`threading.RLock`类实现。

在锁实例上执行`acquire()`和`release()`方法来获取和释放锁。当使用`acquire()`方法给某个锁上锁后，再次对同一个锁执行`acquire()`操作将阻塞，直到该锁被`release()`方法释放。

可以多次实例化`Lock`和`RLock`类得到多个锁。

锁可以用于对多个线程**共享变量**进行操作的场景。为了避免不同线程同时对某个共享变量进行修改操作造成意外的结果，在一个线程需要对这个变量进行修改操作前先获取与这个变量相关的锁，这样其他线程想要获取同样的锁时会被阻塞，在修改完成后释放锁，让其他线程有机会获取该锁来操作这个变量。

简单锁和可重入锁的**区别**在于:

- 简单锁全局只能上锁一次，必须被释放后才能再次上锁；
- 对于可重入锁，上锁的线程可以对该锁多次执行上锁操作，每次执行一次`acquire()`，其内部维护的一个计数变量加1，每次执行一次`release()`，该计数变量减1。只有当该计数变量重新回到0时，其他线程才有可能获取可重入锁。

#### 2. 条件变量

`threading.Condition`类实现了**条件变量**机制。

一个条件变量总是和一个锁绑定，如果实例化条件变量时，没有指定相应的锁，则默认新建一个可重入锁。

```
cv = threading.Condition(lock=None)
```

条件变量用于线程同步的工作机制为：在一个线程中调用`cv.wait()`阻塞线程，等待其他线程调用`cv.notify()`以获得通知。

条件变量中的锁状态变化：
- 调用`wait()`方法的线程会释放条件变量中的锁，当条件变量被`notify()`唤醒后重新获取锁；
- 调用`notify()`方法使得因`wait()`被阻塞的线程被唤醒，但是不会释放其中的锁，所以在被阻塞的线程中，`wait()`方法可能不会立即返回，直到调用`notify()`方法的线程释放掉条件变量中的锁。可以使用**上下文管理器**自动处理这个步骤。

条件变量典型的用法如下：
```
# Consume one item
with cv:
    while not an_item_is_available():
        cv.wait()
    get_an_available_item()

# Produce one item
with cv:
    make_an_item_available()
    cv.notify()
```

其中可以使用`cv.wait_for(an_item_is_available())`来替换其中的while循环。

代码中的`with`语句在进入时会自动获取条件变量的锁，离开后释放锁。

#### 3. 事件同步

Event机制是一种非常简单的线程间同步方法：一个线程设置`set()`事件，另一个线程等待`wait()` 事件。

`wait()`方法阻塞直到事件被`set()`，可以使用`clear()`方法重置事件。





