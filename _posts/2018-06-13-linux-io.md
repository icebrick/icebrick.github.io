---
title: Linux select/poll/信号驱动io/epoll机制
key: 20180613
tags: linux epoll
---

介绍Linux系统下对于同时监控多个文件描述符状态的不同方案，包括select/poll、信号驱动I/O和epoll机制。
<!--more-->

---
当需要同时检查多个文件描述符，看他们是否准备好执行I/O操作(I/O操作是否可以非阻塞地执行)，有如下不同方案可以选择：

- I/O多路复用技术(select和poll),允许进程同时检查多个文件描述符以找出它们中的任何一个是否可执行I/O操作。
- 信号驱动I/O，当有输入或者数据可写到指定的文件描述符上时，内核向请求数据的进程发送一个信号。当同时检查大量文件描述符时，信号驱动I/O相比select和poll有显著的性能提升。
- epoll(linux特有)，相比select和poll，当监控大量文件描述符时，性能更好。

libevent库提供了以上所有的方案的实现。

#### 文件描述符准备就绪的通知模式

- 水平触发：如果文件描述符上可以非阻塞地执行I/O系统调用，此时认为它已经就绪。
- 边缘触发：如果文件描述符自上次状态检查状态以来有了新的I/O活动(比如新的输入)，此时需要触发通知。

I/O模式 | 水平触发 | 边缘触发
--------|---------|---------
select, poll | yes | no
信号驱动I/O  | no | yes
epoll | yes | yes

#### 不同触发模式的选择

- 水平触发：我们可以在**任意时刻**去检查文件描述符的就绪状态，因此没有必要在文件描述符就绪时尽可能多地执行I/O操作(与边缘触发相对)。
- 边缘触发：只有当I/O事件发生时我们才会收到通知，即在另一个I/O事件到来之前不会再收到任何通知。因此应用程序在收到通知后，应该仅可能多的执行I/O操作，直到系统调用以错误码EAGAIN或EWOULDBLOCK形式失败(应设置文件为非阻塞形式O_NONBLOCK打开)，否则可能失去执行I/O的机会了。如我们收到内核通知某文件描述符有数据写入了（可读），此时我们如果只读取了其中的一部分数据，之后将无法确定该文件描述符是否还是可读的。

#### select模型

select多路复用技术是使用系统调用`select()`实现的。该函数的原型为：
``` c
#include <sys/time.h>
#include <sys/select.h>

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```
该函数返回就绪的文件描述符的数量，超时返回0，出错返回-1。readfds, writefds, exceptfds分别为需要监控可读，可写和发生异常的一组文件描述符集合。linux中文件集合最大容量为1024。

该函数返回时会将readfds, writefds和exceptfds所指向的结构修改为就绪的处于就绪态的文件描述符集合。因此如果需要在循环中调用该函数，每次需要重新初始化这三个变量。

#### poll模型

poll多路复用技术是使用系统调用`poll()`实现的。该函数的原型为：

``` c
#include <poll.h>

int poll(struct pollfd fds[], nfds_t nfds, int timeout);
```
该系统调用与select()函数的区别主要在于指定待检查的文件描述符的方式。在select()中我们提供三个集合，分别表示希望检查的事件类型。而在poll()中使用fds数组，每一个数组元素是一个pollfd结构，其中包括要检查的文件描述符和事件。

pollfd结构定义如下：

```
struct pollfd {
    int fd;           /*文件描述符*/
    short events;     /*请求检查的事件位掩码*/
    short revents;    /*返回的就绪的事件位掩码*/
}
```

poll()调用返回一个整数值，-1表示出错，0表示超时，正整数表示就绪的文件描述符数量，即数组fds中拥有非零revents字段的pollfd结构体的数量。

poll()对于被检查文件描述符数量本质上没有限制。

#### select和poll比较

在linux内核层面，select()和poll()都使用了相同的内核poll例程集合，每个例程返回有关单个文件描述符就绪的信息。poll()系统调用的实现包括为每个文件描述符调用内核poll例程，并将结果信息填到对应的revents字段中去。

linux下select()对检查的文件描述符有1024数量的限制，而poll()没有。


select()每次调用需要重新初始化fd_set参数，而poll()通过两个独立的字段events和revents将输入和输出分隔开，从而避免每次重新初始化参数。

poll()和select()在下列两种情况下性能差异很小：

- 待检查的文件描述符范围很小（即最大文件描述符号很低）
- 有大量的文件描述符待检查，但是它们分布得很密集

如果待检查的文件描述符集合很稀疏，两个系统调用的性能差异很大，select()将需要检查从0到最大文件描述符之间的每一个，不管其中的一些文件描述符是否在被检查集合中。而poll()只需要检查那些被设置监控的文件描述符即可。如果最大文件描述符为N，而被监控的文件描述符数量为M，则select()时间复杂度为O(N)，而poll()时间复杂度为O(M)。

`linux 2.6版本中这个性能差异已经被极大地缩小了`

#### select和poll存在的问题

- 每次调用select()和poll()，系统都必须检查所有被指定的文件描述符，看它们是否处于就绪态。当检查大量的文件描述符时，这个操作非常耗时。
- 每次调用select()和poll()时，应用程序都必须传递一个表示需要被检查的文件描述符集合的数据结构到内核(对于select()，每次还需要重新初始化该数据结构)，内核再将结果返回给应用程序，即内核不能记住需要检查的文件描述符集合。当有大量的文件描述符时，从用户空间到内核空间来回拷贝这个数据结构将占用大量的CPU时间。
- 调用完成后，应用程序必须检查返回的数据结构中的每个元素，获得其中已就绪的文件描述符。

信号驱动I/O和epoll模型可以提供更好的性能。

#### 信号驱动I/O

信号驱动I/O中，当文件描述符上可执行I/O操作时，进程请求内核为自己发送一个信号。

使用信号驱动I/O，程序需要按照如下步骤来执行：

1. 为内核发送的通知信号安装一个信号处理例程。默认情况下，通知信号为SIGIO，因为该信号为标准非排队信号，所以一般会自定义一个可以排队的实时信号。
2. 设定文件描述符的属主，即接收通知信号的进程或进程组，一般让调用进程成为属主。
3. 通过设定O_NONBLOCK标志使能非阻塞I/O
4. 通过打开O_ASYNC标志使能信号驱动I/O。
5. 调用进程继续执行其他任务。当I/O操作就绪时，内核为进程发送一个信号，然后调用为信号安装的信号处理函数。
6. 信号驱动I/O使用的是`边缘触发通知`。所以一旦文件描述符就绪，应该尽可能多的执行I/O操作。

信号驱动I/O模型中内核可以`记住`要检查的文件描述符，且只有I/O事件实际发生时才会向程序发送信号。所以信号驱动I/O模型可以根据发送的I/O事件的数量扩展，而与被检查的文件描述符数量无关。如果实际发送I/O时间的数量是P，则时间复杂度为O(P)。


#### epoll模型

epoll相对于select/poll和信号驱动I/O主要的优点如下：

- 当检查大量的文件描述符时，epoll的性能延展性比select()和poll()高很多。
- epoll既支持`水平触发`也支持`边缘触发`。
- 与信号驱动I/O相比，epoll避免了复杂的信号处理流程；灵活性更强，可以指定我们希望检查的事件类型。

epoll的核心数据结构称为epoll实例，它和一个打开的文件描述符相关联。这个文件描述符不是用来做I/O操作的，相反，它是内核数据结构的句柄。这些内核数据结构实现了两个目的：

- 记录了在进程中声明过的感兴趣的文件描述符列表
- 维护了处于I/O就绪态的文件描述符列表

由于epoll实例指向的数据结构存在与内核中，而不是用户空间，内核可以记住我们感兴趣的文件描述符集合，这样就不用在每次调用时从用户空间向内核空间传送文件描述符集合，节省大量的cpu时间。

epoll API由以下3个系统调用组成：

- epoll_create()创建一个epoll实例，返回该实例的文件描述符。
- epoll_ctl()增加，修改和移除epoll实例中的感兴趣的文件描述符和监控事件。
- epoll_wait()返回与epoll实例相关联的就绪列表中的成员。

通过epoll\_ctl()指定了需要监视的文件描述符时，内核会在与打开的文件描述上下文相关联的列表中记录该描述符，之后每当文件描述符就绪时，内核就在epoll描述符的就绪列表中添加一个元素，之后的epoll\_wait()调用从就绪列表中简单地取回这些元素。

上面的过程说明，相对于select/poll调用，内核不需要遍历检查每一个被监视的文件描述符确定其就绪状态，返回结果后应用程序也不需要遍历结果数据结构确定具体是哪些文件描述符就绪。


#### 使用边缘触发通知时文件描述符饥饿现象

当采用边缘触发通知(信号驱动I/O，epoll选择边缘触发)时，如果一个就绪态的文件描述符上有着大量的输入存在，我们将尝试通过非阻塞的读操作将所有的输入都读取，那么此时其他文件描述符将有处于饥饿状态的风险。

该问题的一个解决方案是维护一个列表，其中存放着已被通知就绪态的文件描述符，通过循环不断处理这个列表：

- 将处于就绪状态的文件描述符加到这个列表中
- 应用程序只列表中就绪态的文件描述符上进行一定限度的I/O操作(采用轮转调度(round-robin)方式循环处理，而不是每次都从列表头处理)。当非阻塞I/O调用返回EAGAIN或EWOULDBLOCK错误时，从列表中移除该文件描述符。



